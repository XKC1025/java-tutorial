多线程:
	在内存中分配多个与main主线程类似的栈空间, 多个线程之间互不影响, 运行时抢夺CPU运行权
	thread.run()是在main线程中, 开辟方法调用栈, 不是开启多线程
	
获取线程:
	1.继承Thread类
	2.实现Runnable接口, 并在Thread(Runnable runnable)中创建线程对象
	3.调用thread.start()方法
	
并发与并行:
	并发: 多个任务在同一时间段内发生, 单核分时间片段处理多个任务 
	并行: 多个任务同时发生, 同时执行, 多核同时处理多个任务
	
进程:
	内存中独立运行的应用程序, 占用的内存空间是相互隔离的
	是系统运行程序的基本单位, 即一个进程从创建->运行->消亡的过程
	资源分配的基本单位
	
线程:
	进程中的一个执行单元, 一个进程至少有一个线程
	任务调度的基本单位
	
主线程:
	执行main()方法的线程, main()方法到内存栈, CPU开始执行, 调用其它方法就在main()线程栈中加载方法, 开启新线程就开辟新的线程栈
		
线程调度:
	分时调度:
		所有的线程轮流使用CPU的使用权, 平均分配每个线程占用CPU时间
	抢占式调度:
		优先让优先级高的线程使用CPU, 相同优先级的线程, CPU随机执行. Java线程为抢占式调度	
		
线程安全:
	多线程访问共享数据

解决线程安全:
	同步机制:
		1.同步代码块
		2.同步方法
		3.锁机制
		
线程池:
	复用线程, 线程执行完任务不被销毁, 继续执行下一个任务
	底层用LinkedList<Thread>保存多个线程, list.removeFirst()返回一个线程, 当使用完毕线程, list.add()添加到线程池(队列)
	
线程间通信 / 等待唤醒机制:
	多个线程在处理同一个资源, 但是线程的任务不相同
	生产者-消费者模式, 多线程协同完成一个任务
	多个线程在操作同一份数据时, 避免对同一共享变量的争夺, 高效利用有限资源
	步骤:
		consumer判断变量为false -> consumer唤醒producer -> consumer阻塞等待 -> producer修改变量为true ->
		consumer判断变量为true  -> producer唤醒consumer -> consumer消费    -> consumer修改变量为false ->
		consumer唤醒producer
	wait方法:
		线程不再活动, 不参与调度, 进入WAITING状态, 等待通知(notify), 重新进入调度队列
	notify方法:
		通知WAITING状态等待最久的线程活动
	notifyAll方法:
		唤醒所有等待的线程
	wait和notify方法必须由同一个锁对象调用, 对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程
	wait和notify方法属于Object, 锁对象可以是任意对象
	wait和notify方法必须在同步代码块/同步函数中使用, 因为必须通过锁对象才能调用
